# Project2_SimpleKernel 实验过程文档

##  ——Part2

+ 说明：Part2中主要函数的功能、PCB结构、调度和锁机制等见[part2_design_review.md](part2_design_review.md)，本文主要介绍实验过程中遇到的具体问题及其解决措施

  

### 用户程序信息加载错误

1. 错误现象：

   加载函数过程中发现除法了`blocks reads error`错误，且只在加载部分程序时会出错

2. debug过程：

   + 首先进行了gdb调试，发现在加载`lock1`程序时，读取的用户程序信息entry（即该程序在镜像中的偏移）有误，导致了`bios_sdread`函数错误
   + 进而查看在制作镜像时的相关信息，发现`lock1`和编译的vaddr为0x52000000，与task2成功版本中的0x52060000不一致。
   + 由于vaddr应该是每个程序进行编译时候指定，因此考虑发生编译错误，即使文件修改完毕，镜像制作仍使用之前错误编译的文件。
   + 更新之后部分原先出错的程序得以成功加载，但是仍有部分函数加载出错。
   + 继续使用gdb进行调试，发现对于加载出错的函数，其传入bios_sdread函数的参数entry为负值。查看其二进制，发现已经超过了原本设置的类型short的范围，导致了溢出。
   + 将用户信息结构体中short类型变量更改为int型，并相应更改制作镜像和读取该变量的相关大小，全部程序均得以成功加载。

3. 问题总结：

   + 由于第一次语法编译失败，指定了vaddr为52000000，但是再次编译时，并未重新指定。处理方法是在make all时加一步清理中间文件，保证每次文件编译时都能重新进行vaddr指定。
   + 由于本次用户程序大小增加，在镜像中的偏移也相应增加，超过了short类型表示范围，导致了溢出。处理方法是将用户信息结构体中short类型变量更改为int型，并更改相关存取逻辑。



### 取指错误

1. 错误现象：

   运行`setup_exception`函数时，报错指令异常

2. debug过程：

   + 首先进行gdb调试，发现在该函数执行到末尾时报错。
   + 根据报错的epc查看反汇编文件，发现并未查找到对应pc的指令，且该epc对应setup_exception函数最后一条指令的pc+4。
   + 分析不同指令的取指过程，发现对于最后一条csrw指令，下一次取指仍应是pc顺序更新，但在该函数中已经没有下一条指令，因此报错。
   + 再次分析该函数的调用和返回，由于该函数由汇编语言实现，并非为C语言实现的void函数，因此需要自行实现返回逻辑，需要在末尾通过ret指令进行返回。

3. 问题总结：

   在汇编语言实现的函数中，遗漏了末尾ret指令，因此无法返回调用位置，触发取指错误。在后续汇编语言实现函数中，自行处理相关返回逻辑。



### 系统调用错误

1. 错误现象：

   在用户进行第一次进行系统调用时，并未进入异常处理函数入口，且QEMU报错显示`n=0x16`

2. debug过程：

   + 猜测ecall指令执行错误是因为程序当前状态设置有误，结合faq中的问题解答可知，该错误是因为在执行ecall时CPU仍处于内核态，通过ecall进入了u-boot(BIOS)中。u-boot将系统调用作为SBI调用处理，但SBI调用号不包括0x16，为无效调用号，被打印了出来。
   + 结合上述情况，就应当保证在进入用户程序之后状态应当改变为内核态。因此，不应当在`switch_to`的时候将ra指定为函数入口，因为`switch_to`函数运行在内核态，如果直接通过jr ra进入用户程序，状态无法更改。
   + 进一步结合指令集进行考虑，发现状态的更改会发生在sret指令。执行该指令时，硬件会自动将pc更新为`epc`，将`sstatus`状态寄存器中的`SIE`位更新为`SPIE`位，并将状态更改为`SPP`位。结合在初始化内核栈过程中，已经将`sstatus`对应位置进行初始化，且会在恢复上下文时将寄存器更新为内核栈中的值，并执行`sret`指令，因此`switch_to`应当先返回`ret_from_exception`进行上下文恢复，再从该函数执行sret指令跳转到用户函数，由此实现从内核态到用户态的更改。

3. 问题总结：

   第一次调用用户程序流程有误，导致在内核态执行ecall指令，引发报错。第一次从内核态进入用户态的流程应当为`switch_to`->`ret_from_exception`-> 用户程序



### 时钟中断错误

1. 错误现象：

   在main函数中第一次设置定时器后，运行时进入`exception_handler_entry`就发生了报错。

2. debug过程：

   + 首先分析时钟中断时，被标记上中断的指令，发现是发生在main函数while循环内的一条指令，也即此时程序仍然运行在内核态上。而内核态是不允许中断的，由此触发了错误。
   + 因此，应当保证时钟中断到来时，CPU要运行在用户态上，即正在运行用户程序，故需要在main函数设置定时器后，通过运行一次do_scheduler函数进入用户程序，从而使中断在CPU处于用户态时到来。

3. 问题总结：

   该问题和系统调用错误的问题在本质上是相似的，都是对异常/中断应该在什么时候发生了解的不够深刻。



### 定时器频率设置

1. 错误现象：
   + 当定时器频率设置过高时，发现进入第一个线程后就发生了停滞。一方面时钟中断处理和进程切换开销大，多线程执行效率低；另一方面当定时器倒计时为0时内核处理还未结束，由于内核态屏蔽该中断，导致了中断失效，无法重置定时器，再次通过时钟中断进行调度。
   + 当定时器频率设置过低时，发现进程切换频率过低，无法充分利用多进程与多线程的优势
   + 运行时偶尔会出现卡顿暂停的现象
2. debug过程：
   + 综合qemu调试和上板测试，调整定时器中断频率并查看相关现象。最终选择一个能体现进程切换，且切换频率合适的频率。
   + 将重置定时器移至handler_syscall结尾，可以避免中断频率设置过高，内核处理程序处理未结束的问题。
   + 针对卡顿暂停的现象，发现可以通过输入`ctrl+A`令其继续运行。

3. 问题总结：

   + 在引入时钟中断后，定时器频率的设置是需要重点考虑的因素。如果中断来临太频繁，进程调度次数过高，导致其开销过大，就会影响总体执行的效率；但是如果中断来临频率太低，也可能会无法充分发挥多进程/多线程的效率优势，甚至带来一系列的问题，例如，可能导致睡眠队列检查不够及时，可能导致唤醒时间不同的进程唤醒时间相近，导致其执行顺序与预期不符，影响函数功能实现。

   + 综上，应当在定时器频率上寻找一个平衡点以更加高效的利用时钟中断进行进程调度。



### 线程创建错误

1. 错误现象：

   创建线程后出错，报错信息为各通用寄存器值。

2. debug过程：

   + 通过gdb进行调试，发现在调度至子线程时出错，出错指令为int tid = *(int *)arg，检查arg值，发现为0，与传参时所传的地址不符。
   + 检查创建线程函数中的值，发现在`thread_create`函数中设置变量时将传参位置`a0`错误的赋值为参数arg所指向的值，导致在子线程开始运行时，访问了地址为0的区域，触发了错误。

3. 问题总结：

   该问题主要由于传参过程中，处理参数方式不统一，导致在参数传递过程中从地址变为了地址中所存的值，触发了错误。



### 线程结束错误

1. 错误现象：

   当子线程执行结束后出错。

2. debug过程：

   + 该错误是由于还未完成子线程的回收导致的。在线程执行结束后，由于并非通过调用进入该函数，也就无法直接返回。对于该问题的处理，主要有以下几种方式：
   + 首先，最简单的方式是在线程结尾设置死循环，导致线程无法终止，也无需考虑回收问题。
   + 其次，可以在子线程所运行的函数尾部手动加入系统调用，进行进程调度，且保证当前进程不再进入调度队列中。
   + 最后，一个更加通用、高效的方式是，在每个子线程创建时，都令其运行的函数返回一个系统调用函数，而这个系统调用函数将会负责进行用户栈、内核栈、tcb线程块所占用内存的回收，并进行进程调度，且保证当前进程不再进入调度队列中。
     + 在这种处理方式中，需要额外修改内存分配函数，并且应当更改子进程的内核栈：epc仍设置为用户函数地址，从而通过`sret`指令可以进入用户函数；regs_context_t结构体中的ra应当设置为用户态的进程回收函数地址，在恢复上下文时将会设置为用户程序的返回地址。
     + 详细介绍可见[part2_design_review.md](part2_design_review.md)中线程相关部分

3. 问题总结：

   在维护进程和线程时，应当考虑到其运行状态，特别应当注意的是其创建和回收。特别的，对于一个可以多次创建进程和线程的操作系统，更应当考虑对已结束或无效的进程和线程所用到资源的回收，以实现对于有限内存的高效利用。
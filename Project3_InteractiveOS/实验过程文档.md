# Project3_InteractiveOS 实验过程文档

+ 说明：Prj3中主要shell命令的处理代码及实现要点、各类同步信号量的处理流程及相关进程的资源释放、多核相关处理、关于信号量和进程回收的讨论等见[design_review.md](design_review.md)，本文主要介绍实验过程中遇到的具体问题及其解决措施



### shell回显的实现错误

1. 错误现象

   打印字符时出现打印混乱等情形。

2. 调试过程

   + 首先进行gdb调试，发现shell进程获取的值及其传入内核的值均正确无误，因此将错误定位到具体函数`port_write_ch`中
   + 思考函数实现逻辑，应当借助于屏幕缓冲区进行实现，因此需要利用screen.c中相关函数进行实现
   + 使用`printf("%c",ch)`语句进行打印，可以将字符转化为字符串进行打印，从而与已有API适应。

3. 问题总结

   + 用户态的打印，均通过屏幕缓冲区进行实现，可以依赖于current_running指示的光标位置进行打印，从而保证屏幕显示的正确性。

     

### screen滚屏实现错误

1. 错误现象

   打印到达页面底部触发滚屏，部分打印信息缺失。

2. 调试过程
   + 首先进行gdb调试，发现需打印的信息成功进入new_screen中。触发滚屏时，将new_screen更新为old_screen偏移后的数据，由于需打印的信息还未进入old_screen，就进行了滚屏，导致了部分打印信息的缺失。
   + 考虑在滚屏前先进行一次screen_reflush，将new_screen中的数据更新到old_screen中，再进行滚屏和刷屏。

3. 问题总结：

   在对屏幕缓冲区进行操作前，需要将其更新为最新值，从而避免信息的遗落。操作之后，同样需要再次刷屏，以使得用户可以及时看到更新后的屏幕信息。



###  传参过程出错

1. 错误现象
   + 发现创建用户进程后，无法跳转返回
   + PCB块初始化时，用户程序入口与预期不符
   + 参数由内核态传递出错
   + 进入用户态前参数正确，而main函数读取出错
2. 调试过程
   + 首先进行gdb调试，发现ret_from_exception返回到了exception_handler_entry，即异常程序入口，判断为sepc出现了问题，可能由于用户栈设置出错。检查用户栈指针，发现忘记增加偏移，导致sepc出错。
   + 梳理代码逻辑检查，发现指针数组类型与二维数组类型有所差异，二者在内存中的存放情形有所不同，一个存储形式为连续的指针，而另一者为连续的元素，这也就导致了二者在访问时的差异。根据API进行考虑，传递入内核的形式应当为指针数组。因此在shell进程用户态就设置指针数组指向读取的二维数组。
   + 报错指令异常，继续进行gdb调试定位。在恢复上下文时，检查读取sepc的中间寄存器t0，发现值为0x52000000，与预期不符。进而检查init_pcb中，对进程PCB的相关初始量进行检查，发现由于遍历找到的taskid为0，导致了entrypoint出错。
   + 由于taskid通过待启动任务的名字与加载至内存的程序信息比对获得。将待启动任务的名字和各程序信息进行打印，发现由于先前结构体定义中字符数组长度设置较小，部分任务名字无法全部存储（如`ready_to-exit`），因此，需同时修改内核函数和createimage工具中程序信息结构体定义。
   + 参数排布仍然有误，通过gdb进行查看时，发现指向存储指针位置的指针每次将会加上64（代码实现中每次加上`sizeof(char *)`），与预期不符。这是因为针对特定类型的加法时，将会自动将所加数乘以类型大小，获得真实的内存偏移，因此如需指向下一个指针位置，只需加1即可。
   + 内核态sret之前a0、a1正确无误，但在main函数读取时出现错误。综合gdb调试和代码逻辑梳理可知，sret会首先返回`crt0`完成系列准备工作，再进入`main`函数。因此，需要在`crt0`中保证传参的不被更改，可通过压栈和退栈进行实现。
3. 问题总结：
   + 进行结构体定义时，需要考虑边界条件，兼顾开销和可用性
   + 参数传递时，需要熟悉代码运行流程。对于数据传输出错的情形，应当跟踪其传输过程的各个阶段，从而进行错误的定位和解决
   + 进行传参和存储时，应当注意不同变量类型的存储方式、栈的存储方式（高低地址等）、C语言语法中的相关操作。



### 定时器设置错误

1. 错误现象

   实现双核之后，运行屏障测试任务，发现陷入堵塞。

2. 调试过程
   + 首先通过gdb调试，发现该进程停留在用户态，不再通过时间中断进入内核态。经过分析，可能是该进程错过了时钟中断。
   + 进一步分析该进程的调度流程。该进程由初始进程调度而来，时间中断在循环外设置。因此，当对应的处理器核多次找不到下一个可用进程可被迫调度至初始进程后，将会导致后续调度到该核的进程错过中断。
   + 考虑更改时间中断位置。如果在将其设置在main的循环之中，则对调度至初始进程的情形，也会设置无效的时间中断。从节约开销的角度考虑，将定时器设置放置于`do_scheduler`中完成。当前进程为初始进程，将调度进程为用户进程时，进行时钟中断设置，以使得用户进程能够再次返回内核态。

3. 问题总结

   + 在基于时间中断的抢占式调度机制下，每个时间中断都不应该被错过，否则可能陷入进程用户态而无法返回。因此，需要对定时器的设置进行特别考虑。

   + 特别应当注意的是，引入双核之后，如果某核没有下一个符合条件的就绪任务，就会调度至初始进程，在此循环操作，等待下一个就绪任务的出现。由于这种循环等待的性质，应当在满足用户进程调度条件时才进行定时器设置，以避免设置过早导致的错过和设置过频繁带来的额外开销。



### 堵塞失败

1. 错误现象

   waitpid/sleep等将进程进行堵塞的操作失效。

2. 调试过程

   + 首先使用gdb进行跟踪调试，发现确实执行了do_block操作，但在调度时，该版本代码方案为，如果不存在下一个可调度进程，则switch_to至本身，也即该进程继续占用CPU运行，这导致了堵塞的失效
   + 梳理代码逻辑并设计新方案，当不存在下一个可调度进程时，将调度至初始进程，从而阻止被堵塞的进程继续占据CPU运行，保证了堵塞的正确实现。

3. 问题总结

   + 针对更改进程状态的操作，需要在相关机制下都能保证操作的有效性。同时，应当特别注意调度部分逻辑，这决定了真正占用CPU运行的程序。

     

### 队列实现错误

1. 错误现象
   + 睡眠队列处错误导致陷入死循环
   + 就绪队列处错误导致进程堵塞
2. 调试过程
   + 发现陷入死循环时，通过gdb进行调试定位，发现死循环发生在睡眠队列检查位置。检测代码运行过程，并记录队列的改变。
   + 梳理代码逻辑，使用队头标记法（即队头出队，不符合条件的再次入队，再次检测到队头时，表示队列遍历完成）时，需要考虑到队头不再入队、而部分成员重新入队的情形。当队头出队时，应当重新选择队头，并标记初次访问，从而保证队列遍历的正确性。
   + 发现进程堵塞，没有进程被执行。
   + 通过gdb跟踪调试，将问题定位至`do_scheduler`函数对于就绪队列的维护中。梳理代码逻辑，发现虽然该队列主要逻辑同睡眠队列类似，但API实现有所不同，next_running首先通过dequeue拿出，已经修改了队列内容。因此，有别于睡眠队列的实现，就绪队列需要分别考虑为空和再次访问队头的情形。对于后者，需要再次将其加入就绪队列当中，防止另一个核的就绪进程被丢弃。

3. 问题总结

   在队列等存储结构的访问逻辑中，既要考虑与API联系的相关操作，也应当额外对边界情况、特殊情况进行考虑，从而保证队列实现的正确性。

   

### 内核锁实现错误

1. 错误现象

   运行`multicore`任务时加速比接近1，且`ps`命令显示只有一个程序运行在核上。

2. 调试过程

   + 分析代码流程，将问题定位至调度部分
   + 使用gdb跟踪双核运行到不同位置时，锁的占用情况，发现满足互斥访问。但是有一个CPU频繁占用和释放内核锁，且仍不满足调度条件。浪费了大量资源。
   + 分析代码逻辑后，对于无就绪进程的情况，调度至初始进程。
   + 考虑到未成功调度的进程不应该始终占有内核锁，导致有就绪任务的核反而无法运行。每次需要进行锁的释放和再申请。

3. 问题总结

   由于CPU获取下一个就绪进程的方式是遍历队列，为了保证当前进程的释放，就需要调度至初始进程作为过渡。

   

### 进程回收错误

1. 错误现象
   + 将资源释放和取消PCB块占用均立即实现时，造成新进程出错
   + 将上述二者放置在调度时完成时，产生了僵尸进程
2. 调试过程
   + 最初在杀死进程时，立即进行资源释放和取消PCB块占用。再次创建新进程时，利用了仍在阻塞队列中的已杀死进程pid。导致该进程同时处于两个队列，造成错误。
   + 尝试将上述二者均在调度时完成，发现对于阻塞进程，如其资源不及时释放，可能不再被调度，产生僵尸进程（即已杀死，但仍存在）
   + 采用进程组思想，通过杀死父进程时杀死所有子进程，并释放同步信号，避免上述二种情况的发现。

3. 问题总结
   + 基于现有的API，选择将资源释放在杀死时立即完成，而将取消PCB块占用放置在调度时完成。
4. 讨论与思考
   + 对于取消PCB块占用标志，可以有以下几种考虑。
   + 如果相关API允许从队列中间进行删除，也可以在杀死时就将其从队列中取出，并取消占用，这种情形可避免新进程同时处于两个队列的错误。
   + 相比原方案，上述方案有两个可能的缺陷：
     + 首先，需要对具体队列的情形进行考虑，如进程处于队头队尾等。针对该缺陷，可使用循环链表以简化实现的情形考虑。
     + 其次，对于一些特殊的实现方式，一个将被杀死的进程可能同时处于多个阻塞队列中，为实现带来了更高的复杂度。
   + 相比之下，原方案只需考虑唯一存在的就绪队列，也只需要考虑待杀死元素的队头的情形，实现上更为简单，开销相近，且效果相同（子进程同样可被真正杀死。综上，选择使用原方案进行实现

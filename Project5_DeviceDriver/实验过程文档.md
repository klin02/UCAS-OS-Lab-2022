# Project5_DeviceDriver 实验过程文档

+ 说明：prj5中关于发送/接收描述符相关内容、网卡中断相关流程、收包检查的介绍和细节等见[design_review.md](design_review.md)，本文主要介绍实验过程中遇到的具体问题及解决措施

### 接收数据包错误

1. 错误现象

   接受进程无法收到包，陷入阻塞。

2. 调试过程

   添加打印语句打印头尾指针，并进一步梳理功能实现逻辑发现，头尾指针初始化出错。应当将头指针设为0，尾指针设置为循环队列程度减1。从而硬件可以在接收时，自动向后移动头指针，而软件在检测到尾指针后一个位置已经接受完成之后，则可以移动尾指针进行接收。
   对于MAC寄存器的设置，除了需要将RAH寄存器最高位置高之后，地址排列与enetaddr数组相反，示意如下：

   + RAL0：

   | 31:24     | 23:16     | 15:8      | 7:0       |
   | --------- | --------- | --------- | --------- |
   | ethaddr[] | ethaddr[] | ethaddr[] | ethaddr[] |

   + RAH0:

   | 31     | 30:16    | 15:8      | 7:0       |
   | ------ | -------- | --------- | --------- |
   | RAH_AV | RESERVED | ethaddr[] | ethaddr[] |

3. 问题总结

   实现接收功能时理解有误，头尾指针初始化和移动方向理解错误。MAC地址设置出错。接受进程无法收到包，陷入阻塞。

### 网卡中断使能错误

1. 错误现象

   在e1000_init和plic_init前使能SIE寄存器的SEIE位，则在初始化TX发送描述符时触发了内核态中断陷入阻塞。如果在e1000_init和plit_init之后进行使能，则在使能时触发内核态中断陷入阻塞。

2. 调试过程

   + 由于plic网卡中断使能在板卡上测试，故只能通过添加print语句定位错误。

   + 首先通过打印，确定了堵塞位置，由上述错误现象，可以推断并未成功关闭网卡中断。因此需要查看e1000和plic的初始化实现。

   + 由于sret等返回指令，在内核态陷入中断无法最终返回中断前位置执行，但添加中断前的tp寄存器指定，可以执行部分中断处理函数确认原因。发现产生中断的中断源为1号或3号，推测在plic中关闭其他中断源出了问题。

   + 梳理plic代码逻辑，发现应该将框架代码中循环关闭其他中断源的代码由
     ```c
     for (hwirq = 1; hwirq <= nr_irqs; hwirq++) 
         plic_toggle(handler, hwirq, 1);
     ```

     改为

     ```c
     for (hwirq = 1; hwirq <= nr_irqs; hwirq++) 
         plic_toggle(handler, hwirq, 0);
     ```

     该更改表示禁用全部中断源，在下方的```plic_irq_unmask```，会再行将网卡中断源使能。

   + 完成上述更改后，内核态不再陷入中断而阻塞。但网卡中断并未如预期打开，执行收发包时，陷入阻塞。经过助教检查框架代码，发现网卡中断号应当为3而非2，更改之后，可以正常执行功能。
   + 上述对网卡中断的使能仍仅限于在主核上进行使能。从核使能网卡中断之后，仍会在内核态触发中断。类似上述主核查看内核态中断的方法，发现是0号中断源触发的外设中断。询问助教后，可能是框架实现问题，将部分其余中断合并到0号中断源中，导致了错误的中断。由于该错误无法解决，因此在双核功能实现中，主核和从核均可进行收发工作，但只有主核处理网卡中断。

3. 问题总结

   在prj5的设计和调试过程中，网卡中断问题的相关处理是最主要面对的困难。这要求对整个框架和网卡相关初始化的过程有更深刻的了解，同时也需要掌握更加精准的定位错误方法，从而正确发现代码或框架中的隐藏问题。

   

